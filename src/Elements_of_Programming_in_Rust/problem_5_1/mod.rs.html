<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src/problem_5_1/mod.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>mod.rs - source</title><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled ><script id="default-settings"></script><script src="../../../storage.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../../Elements_of_Programming_in_Rust/index.html'><div class='logo-container rust-logo'><img src='../../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><span class="help-button">?</span>
                <a id="settings-menu" href="../../../settings.html"><img src="../../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
</pre><div class="example-wrap"><pre class="rust ">
<span class="doccomment">//! EOPI pg 39. The Dutch National Flag Problem</span>
<span class="doccomment">//! Write a program that takes an array slice and an index i into slice, and rearranges the elements such</span>
<span class="doccomment">//! that all elements less than slice[r] (the &quot;pivot&quot;) appear first, followed by elements equal to the pivot,</span>
<span class="doccomment">//! followed by elements greater than the pivot.</span>
<span class="doccomment">//! Hint: Think about the partition step in quicksort.</span>

<span class="doccomment">//! [the documentation for the slice primitive comes in handy](https://doc.rust-lang.org/std/primitive.slice.html)</span>

<span class="doccomment">/// the solution keeps track of two pivot points to know the &quot;middle stripe&quot; start and end</span>
<span class="doccomment">/// starting from the beginning it moves larger elements to the end and equal elements to the middle stripe</span>
<span class="doccomment">/// then works on the back half to move smaller elements to the beginning</span>
<span class="doccomment">/// all while making sure not to disturb remaining elements in the start or end loops.</span>
<span class="doccomment">/// This solution has time complexity per slice of O(n^2) because each time we fine an element that is not in the appropriate half</span>
<span class="doccomment">/// we do a rotate which will shift all n elements of the slice - hence &#39;naive&#39;</span>
<span class="kw">fn</span> <span class="ident">flag_sort_naive</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Ord</span><span class="op">&gt;</span>(<span class="ident">slice</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">T</span>], <span class="ident">pivot</span>: <span class="ident">usize</span>) {
    <span class="comment">// base case if the slice is 0 or 1 elements it is already arranged</span>
    <span class="kw">if</span> <span class="ident">slice</span>.<span class="ident">len</span>() <span class="op">&lt;</span> <span class="number">2</span> {
        <span class="kw">return</span>;
    }
    <span class="comment">// pivot cannot be less than 0 or more than the len-1</span>
    <span class="kw">let</span> <span class="ident">pivot</span> <span class="op">=</span> <span class="ident">pivot</span>.<span class="ident">min</span>(<span class="ident">slice</span>.<span class="ident">len</span>() <span class="op">-</span> <span class="number">1</span>);
    <span class="comment">//start and end will track the middle elements equal to the pivot</span>
    <span class="kw">let</span> (<span class="kw-2">mut</span> <span class="ident">start</span>, <span class="kw-2">mut</span> <span class="ident">end</span>) <span class="op">=</span> (<span class="ident">pivot</span>, <span class="ident">pivot</span>);
    <span class="comment">//start at the beginning and will do up to the start (exclusive)</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">i</span> <span class="op">=</span> <span class="number">0</span>;
    <span class="kw">while</span> <span class="ident">i</span> <span class="op">&lt;</span> <span class="ident">start</span> {
        <span class="comment">// element is greated than the pivot value and belongs after the end pivot</span>
        <span class="kw">if</span> <span class="ident">slice</span>[<span class="ident">i</span>] <span class="op">&gt;</span> <span class="ident">slice</span>[<span class="ident">start</span>] {
            <span class="comment">// swap with the first element preserving all elements before start staying before start</span>
            <span class="ident">slice</span>.<span class="ident">swap</span>(<span class="ident">i</span>, <span class="number">0</span>);
            <span class="comment">// and rotate left so that the element now at the beginning moves to the end of the slice</span>
            <span class="ident">slice</span>.<span class="ident">rotate_left</span>(<span class="number">1</span>);
            <span class="comment">// rotate left shifted the start and end down one</span>
            <span class="ident">start</span> <span class="op">-</span><span class="op">=</span> <span class="number">1</span>;
            <span class="ident">end</span> <span class="op">-</span><span class="op">=</span> <span class="number">1</span>;
        }
        <span class="comment">// element equals the pivot value then it belongs as part of the stripe</span>
        <span class="kw">else</span> <span class="kw">if</span> <span class="ident">slice</span>[<span class="ident">i</span>] <span class="op">=</span><span class="op">=</span> <span class="ident">slice</span>[<span class="ident">start</span>] {
            <span class="comment">// put it next to current start pivot</span>
            <span class="ident">slice</span>.<span class="ident">swap</span>(<span class="ident">i</span>, <span class="ident">start</span> <span class="op">-</span> <span class="number">1</span>);
            <span class="comment">// start pivot now is this element after the swap</span>
            <span class="ident">start</span> <span class="op">-</span><span class="op">=</span> <span class="number">1</span>;
        }
        <span class="comment">// unless we moved the current value we do not need to increment the current index</span>
        <span class="comment">// because the current element was otherwise moved to the end and the next value shifted forward</span>
        <span class="kw">else</span> {
            <span class="ident">i</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
        }
    }
    <span class="comment">// now that all elements from the beginning up to the start have been properly arranged</span>
    <span class="comment">// we will work our way from after the end pivot to the end of the slice</span>
    <span class="ident">i</span> <span class="op">=</span> <span class="ident">end</span> <span class="op">+</span> <span class="number">1</span>;
    <span class="kw">while</span> <span class="ident">i</span> <span class="op">&lt;</span> <span class="ident">slice</span>.<span class="ident">len</span>() {
        <span class="comment">// element belongs before start</span>
        <span class="kw">if</span> <span class="ident">slice</span>[<span class="ident">i</span>] <span class="op">&lt;</span> <span class="ident">slice</span>[<span class="ident">start</span>] {
            <span class="comment">// move it to the end (to preserve other elements being located after end)</span>
            <span class="ident">slice</span>.<span class="ident">swap</span>(<span class="ident">i</span>, <span class="ident">slice</span>.<span class="ident">len</span>() <span class="op">-</span> <span class="number">1</span>);
            <span class="comment">// rotate the slice so the element which is now at the end of the slice moves to the beggining</span>
            <span class="ident">slice</span>.<span class="ident">rotate_right</span>(<span class="number">1</span>);

            <span class="comment">// start and end are now 1 futher back</span>
            <span class="ident">start</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
            <span class="ident">end</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
        }
        <span class="comment">// element equals pivot value so becomes part of middle &quot;stripe&quot;</span>
        <span class="kw">else</span> <span class="kw">if</span> <span class="ident">slice</span>[<span class="ident">i</span>] <span class="op">=</span><span class="op">=</span> <span class="ident">slice</span>[<span class="ident">start</span>] {
            <span class="comment">// we put the element after the element after the end pivot (extend the &quot;stripe&quot;)</span>
            <span class="ident">slice</span>.<span class="ident">swap</span>(<span class="ident">i</span>, <span class="ident">end</span> <span class="op">+</span> <span class="number">1</span>);
            <span class="comment">// and end pivot is now the location of this element</span>
            <span class="ident">end</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
        }
        <span class="comment">// regardless of what we do in this loop the index goes forward</span>
        <span class="ident">i</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
    }
    <span class="comment">// recurse over lower &quot;stripe&quot; and upper &quot;stripe&quot;</span>
    <span class="ident">flag_sort_naive</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">slice</span>[..<span class="ident">start</span>], <span class="ident">pivot</span> <span class="op">/</span> <span class="number">2</span>);
    <span class="ident">flag_sort_naive</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">slice</span>[(<span class="ident">end</span> <span class="op">+</span> <span class="number">1</span>)..], <span class="ident">pivot</span> <span class="op">/</span> <span class="number">2</span>);
}

<span class="doccomment">/// sorts a slice of elements implementing Ord</span>
<span class="doccomment">/// iterates through the slice twice - forwards moving elements less than the pivot to the front; backwards moving elements greater than the pivot to the end of the slice.</span>
<span class="doccomment">/// the position of the pivot must be tracked in order to have the pivot value to compare to without having T implement Copy</span>
<span class="doccomment">/// also for the recursive subslicing to work excluding elements equal to the pivot value</span>
<span class="doccomment">/// unlike `flag_sort_naive` the partitioning takes O(n) time since it iterated through the array twice once from the beginning and once from the rear (and two more short iterations from the final pivot location)</span>
<span class="kw">fn</span> <span class="ident">flag_sort</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Ord</span><span class="op">&gt;</span>(<span class="ident">slice</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">T</span>], <span class="ident">pivot</span>: <span class="ident">usize</span>) {
    <span class="comment">// base case if the slice is 0 or 1 elements it is already arranged</span>
    <span class="kw">if</span> <span class="ident">slice</span>.<span class="ident">len</span>() <span class="op">&lt;</span> <span class="number">2</span> {
        <span class="kw">return</span>;
    }
    <span class="comment">// pivot cannot be less than 0 or more than the len-1</span>
    <span class="kw">let</span> <span class="ident">pivot</span> <span class="op">=</span> <span class="ident">pivot</span>.<span class="ident">min</span>(<span class="ident">slice</span>.<span class="ident">len</span>() <span class="op">-</span> <span class="number">1</span>);
    <span class="comment">// count will track how many elements have been moved to the beginning of the slice</span>
    <span class="comment">// it will be used to tell which value can be swapped with when the next value less than the pivot is found</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">count</span> <span class="op">=</span> <span class="number">0</span>;
    <span class="comment">// start represents the position of the pivot as it is potentially moved around by the swapping of elements</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">start</span> <span class="op">=</span> <span class="ident">pivot</span>;
    <span class="comment">// the forward pass moving all elements less than the pivot to the beginning of the slice</span>
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">slice</span>.<span class="ident">len</span>() {
        <span class="comment">// an element less than the slice will be swapped with the element at current `count`</span>
        <span class="kw">if</span> <span class="ident">slice</span>[<span class="ident">i</span>] <span class="op">&lt;</span> <span class="ident">slice</span>[<span class="ident">start</span>] {
            <span class="comment">// we have to check if the element we will be swapping with at `count` is the current position of the pivot i.e. `start`</span>
            <span class="comment">// if it is we need to account for the start value now being moved to position `i`</span>
            <span class="kw">if</span> <span class="ident">count</span> <span class="op">=</span><span class="op">=</span> <span class="ident">start</span> {
                <span class="ident">start</span> <span class="op">=</span> <span class="ident">i</span>;
            }
            <span class="comment">// then we perform the swap and increment `count` so that we know we have put another element in the proper place from the start of the slice</span>
            <span class="ident">slice</span>.<span class="ident">swap</span>(<span class="ident">i</span>, <span class="ident">count</span>);
            <span class="ident">count</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
        }
    }
    <span class="comment">// now we will be putting elements greater than the pivot from the rear of the slice</span>
    <span class="comment">// so count will start with the last element</span>
    <span class="ident">count</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">len</span>() <span class="op">-</span> <span class="number">1</span>;
    <span class="comment">// we perform the backwards pass</span>
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> (<span class="number">0</span>..<span class="ident">slice</span>.<span class="ident">len</span>()).<span class="ident">rev</span>() {
        <span class="comment">// for the backwards pass we already know we have put smalled elements towards the beginning of the slice so if we see one we know we will no longer encounter elements greater than the pivot</span>
        <span class="kw">if</span> <span class="ident">slice</span>[<span class="ident">i</span>] <span class="op">&lt;</span> <span class="ident">slice</span>[<span class="ident">start</span>] {
            <span class="kw">break</span>;
        }
        <span class="kw">if</span> <span class="ident">slice</span>[<span class="ident">i</span>] <span class="op">&gt;</span> <span class="ident">slice</span>[<span class="ident">start</span>] {
            <span class="comment">// we have to check if the element we will be swapping with at `count` is the current position of the pivot i.e. `start`</span>
            <span class="comment">// if it is we need to account for the start value now being moved to position `i`</span>
            <span class="kw">if</span> <span class="ident">count</span> <span class="op">=</span><span class="op">=</span> <span class="ident">start</span> {
                <span class="ident">start</span> <span class="op">=</span> <span class="ident">i</span>;
            }
            <span class="comment">// then we perform the swap and decrement count since we are moving elements to the end of the slice</span>
            <span class="ident">slice</span>.<span class="ident">swap</span>(<span class="ident">i</span>, <span class="ident">count</span>);
            <span class="ident">count</span> <span class="op">-</span><span class="op">=</span> <span class="number">1</span>;
        }
    }

    <span class="comment">// at this point all elements less than the pivot form a contiguous region from the start of the slice up to a middle region of values equal to the pivot value</span>
    <span class="comment">// followed by a contiguos region of elements greater than the pivot</span>
    <span class="comment">// so now we just need to take account of which indices are equal to the pivot i.e. find the middle region of elements equal to the pivot which we will not need to recurse upon</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">left</span> <span class="op">=</span> <span class="number">0</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">right</span> <span class="op">=</span> <span class="number">0</span>;
    <span class="comment">// elements to the left of `start` that are pivot values</span>
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> (<span class="number">0</span>..<span class="ident">start</span>).<span class="ident">rev</span>() {
        <span class="kw">if</span> <span class="ident">slice</span>[<span class="ident">i</span>] <span class="op">=</span><span class="op">=</span> <span class="ident">slice</span>[<span class="ident">start</span>] {
            <span class="ident">left</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
        }
    }
    <span class="comment">// elements to the right of `start` that are pivot values</span>
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> (<span class="ident">start</span> <span class="op">+</span> <span class="number">1</span>)..<span class="ident">slice</span>.<span class="ident">len</span>() {
        <span class="kw">if</span> <span class="ident">slice</span>[<span class="ident">i</span>] <span class="op">=</span><span class="op">=</span> <span class="ident">slice</span>[<span class="ident">start</span>] {
            <span class="ident">right</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
        }
    }
    <span class="comment">// now simply the recursive step performing the partitioning of this function the right and left halves respectively</span>
    <span class="comment">// and again recursively until the slice is sorted</span>
    <span class="ident">flag_sort</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">slice</span>[<span class="number">0</span>..(<span class="ident">start</span> <span class="op">-</span> <span class="ident">left</span>)], <span class="ident">pivot</span> <span class="op">/</span> <span class="number">2</span>);
    <span class="ident">flag_sort</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">slice</span>[(<span class="ident">start</span> <span class="op">+</span> <span class="ident">right</span> <span class="op">+</span> <span class="number">1</span>)..], <span class="ident">pivot</span> <span class="op">/</span> <span class="number">2</span>);
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">test</span>)]</span>
<span class="kw">mod</span> <span class="ident">tests</span> {
    <span class="kw">use</span> <span class="kw">super</span>::<span class="kw-2">*</span>;
    <span class="attribute">#[<span class="ident">test</span>]</span>
    <span class="kw">fn</span> <span class="ident">test_flag_sort</span>() {
        <span class="kw">let</span> <span class="ident">tests</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[
            <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],
            <span class="macro">vec</span><span class="macro">!</span>[<span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">9</span>],
            <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">2</span>],
            <span class="macro">vec</span><span class="macro">!</span>[<span class="number">3</span>, <span class="number">0</span>],
            <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],
        ];
        <span class="kw">for</span> <span class="ident">p</span> <span class="kw">in</span> <span class="number">0</span>..<span class="number">15</span> {
            <span class="kw">for</span> <span class="ident">t</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">tests</span> {
                <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">sol</span> <span class="op">=</span> <span class="ident">t</span>.<span class="ident">clone</span>();
                <span class="ident">sol</span>.<span class="ident">sort</span>();
                <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">things1</span> <span class="op">=</span> <span class="ident">t</span>.<span class="ident">clone</span>();
                <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">things2</span> <span class="op">=</span> <span class="ident">t</span>.<span class="ident">clone</span>();
                <span class="ident">flag_sort_naive</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">things1</span>, <span class="ident">p</span>);
                <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">things1</span>, <span class="ident">sol</span>);
                <span class="ident">flag_sort</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">things2</span>, <span class="ident">p</span>);
                <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">things2</span>, <span class="ident">sol</span>);
            }
        }
    }
}
</pre></div>
</section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../../../";window.currentCrate = "Elements_of_Programming_in_Rust";</script><script src="../../../main.js"></script><script src="../../../source-script.js"></script><script src="../../../source-files.js"></script><script defer src="../../../search-index.js"></script></body></html>